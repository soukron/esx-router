- name: Initialize load balancer facts
  ansible.builtin.set_fact:
    load_balancer_vips_all: []
    load_balancer_vips: []
    load_balancer_vip_interface_map: []

- name: Build load balancer VIPs from clusters
  ansible.builtin.set_fact:
    load_balancer_vips_all: "{{ (load_balancer_vips_all | default([])) + cluster_generated_vips }}"
  vars:
    cluster_generated_vips: >-
      {% set vips = [] -%}
      {% for cluster in clusters_expanded | default([]) -%}
      {% if cluster.lbManaged | default('') == 'user' -%}
      {% set node_list = cluster.nodes.ips | default([]) -%}
      {% set master_nodes = node_list[:3] -%}
      {% set worker_nodes = node_list[3:] if (node_list | length) > 3 else [] -%}
      {% if cluster.apiVIP is defined -%}
      {% set api_backends = master_nodes + ([cluster.bootstrap_ip] if cluster.bootstrap_ip is defined else []) -%}
      {% set _ = vips.append({
        'hostname': 'api.' ~ cluster.domain,
        'vip': cluster.apiVIP,
        'ports': [6443, 22623],
        'backend_ips': api_backends
      }) -%}
      {% if cluster.apiIntVIP is defined and cluster.apiIntVIP != cluster.apiVIP -%}
      {% set _ = vips.append({
        'hostname': 'api-int.' ~ cluster.domain,
        'vip': cluster.apiIntVIP,
        'ports': [6443, 22623],
        'backend_ips': api_backends
      }) -%}
      {% endif -%}
      {% endif -%}
      {% if cluster.ingressVIP is defined -%}
      {% set ingress_backends = (worker_nodes if (node_list | length) > 3 else master_nodes) -%}
      {% set _ = vips.append({
        'hostname': 'apps.' ~ cluster.domain,
        'vip': cluster.ingressVIP,
        'ports': [80, 443],
        'backend_ips': ingress_backends,
        'balance': 'source'
      }) -%}
      {% endif -%}
      {% endif -%}
      {% endfor -%}
      {{ vips }}
  when: clusters_expanded is defined

- name: Filter load balancer VIPs to local interfaces
  ansible.builtin.set_fact:
    load_balancer_vips: >-
      {% set local_vips = [] -%}
      {% for vip in load_balancer_vips_all | default([]) -%}
      {% set vip_ip = (vip.vip | regex_replace('/\\d+$', '')) -%}
      {% set matched = false -%}
      {% for iface in interfaces | default([]) -%}
      {% if (not matched) and (iface.address is defined) and (vip_ip | ansible.utils.ipaddr(iface.address)) -%}
      {% set _ = local_vips.append(vip) -%}
      {% set matched = true -%}
      {% endif -%}
      {% endfor -%}
      {% endfor -%}
      {{ local_vips }}

- name: Determine if load balancer should be managed in this node
  ansible.builtin.set_fact:
    load_balancer_enabled: "{{ load_balancer_vips | default([]) | length > 0 }}"

- name: Reset interface addresses
  ansible.builtin.import_tasks: interface_cleanup.yml
  vars:
    interface_cleanup_interfaces: "{{ interfaces | default([]) }}"
  when: interfaces is defined

- name: Install haproxy
  ansible.builtin.package:
    name: haproxy
    state: present
  when:
  - not skip_package_install | default(false)

- name: Ensure haproxy config directory exists
  ansible.builtin.file:
    path: /etc/haproxy/conf.d
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Deploy haproxy base configuration
  ansible.builtin.template:
    src: haproxy.cfg.j2
    dest: /etc/haproxy/haproxy.cfg
    owner: root
    group: root
    mode: '0644'
  notify: Restart haproxy

- block:
  - name: Clear haproxy cluster configuration when disabled
    ansible.builtin.copy:
      content: ""
      dest: /etc/haproxy/conf.d/clusters.cfg
      owner: root
      group: root
      mode: '0644'

  - name: Stop haproxy service when disabled
    ansible.builtin.systemd:
      name: haproxy
      state: stopped
      enabled: no
    ignore_errors: yes
  when:
  - not load_balancer_enabled | default(false)

- block:
  - name: Build load balancer interface map from VIP subnets
    ansible.builtin.set_fact:
      load_balancer_vip_interface_map: >-
        {% set iface_map = [] -%}
        {% for iface in interfaces | default([]) -%}
        {% set vips = [] -%}
        {% for vip in load_balancer_vips | default([]) -%}
        {% set vip_ip = (vip.vip | regex_replace('/\\d+$', '')) -%}
        {% if (iface.address is defined) and (vip_ip | ansible.utils.ipaddr(iface.address)) -%}
        {% set vip_cidr = vip.vip if (vip.vip | regex_search('/\\d+$')) else (vip_ip ~ '/32') -%}
        {% set _ = vips.append(vip_cidr) -%}
        {% endif -%}
        {% endfor -%}
        {% if vips | length > 0 -%}
        {% set _ = iface_map.append({
          'name': iface.name,
          'desired_addresses': ([iface.address] + (vips | unique | list))
        }) -%}
        {% endif -%}
        {% endfor -%}
        {{ iface_map }}

  - name: Fail when VIPs do not match any interface subnet
    ansible.builtin.fail:
      msg: "Could not map VIPs to any interface: {{ load_balancer_vips | map(attribute='vip') | list }}"
    when: load_balancer_vip_interface_map | length == 0

  - name: Collect configured IPv4 addresses for load balancer interface
    ansible.builtin.command: "nmcli -g ipv4.addresses connection show {{ item.name }}"
    loop: "{{ load_balancer_vip_interface_map }}"
    register: lb_iface_addresses
    changed_when: false
    when: load_balancer_vip_interface_map | length > 0

  - name: Ensure load balancer interface addresses match desired list
    ansible.builtin.command: >-
      nmcli connection modify {{ item.item.name }}
      ipv4.addresses "{{ item.item.desired_addresses | join(',') }}"
    vars:
      existing_addresses: >-
        {{ (item.stdout | default('')).split(',')
           | map('trim')
           | reject('equalto', '')
           | list }}
    when:
    - (existing_addresses | sort) != (item.item.desired_addresses | sort)
    loop: "{{ lb_iface_addresses.results | default([]) }}"
    register: lb_vip_set_results
    changed_when: lb_vip_set_results.rc == 0

  - name: Collect device IPv4 addresses for load balancer interfaces
    ansible.builtin.command: "nmcli -g IP4.ADDRESS device show {{ item.name }}"
    loop: "{{ load_balancer_vip_interface_map }}"
    register: lb_device_addresses
    changed_when: false

  - name: Reapply load balancer interfaces when device addresses differ
    ansible.builtin.command: "nmcli device reapply {{ item.item.name }}"
    vars:
      device_addresses: >-
        {{ (item.stdout | default('')).split('\n')
           | map('trim')
           | reject('equalto', '')
           | list }}
    when:
    - (device_addresses | sort) != (item.item.desired_addresses | sort)
    loop: "{{ lb_device_addresses.results | default([]) }}"
    register: lb_reapply_result
    failed_when: lb_reapply_result.rc not in [0, 10]
    changed_when: lb_reapply_result.rc == 0

  - name: Build load balancer TCP ports list
    ansible.builtin.set_fact:
      load_balancer_tcp_ports: "{{ load_balancer_vips | map(attribute='ports') | list | flatten | unique | sort }}"

  - name: Allow load balancer ports in SELinux
    community.general.seport:
      ports: "{{ item }}"
      proto: tcp
      setype: http_port_t
      state: present
    loop: "{{ load_balancer_tcp_ports }}"
    when:
    - ansible_selinux is defined
    - ansible_selinux.status == "enabled"
    - load_balancer_tcp_ports is defined

  - name: Deploy haproxy cluster configuration
    ansible.builtin.template:
      src: haproxy.clusters.cfg.j2
      dest: /etc/haproxy/conf.d/clusters.cfg
      owner: root
      group: root
      mode: '0644'
    notify: Restart haproxy

  - name: Allow load balancer ports in public zone
    ansible.posix.firewalld:
      zone: public
      port: "{{ item }}/tcp"
      permanent: yes
      state: enabled
    loop: "{{ load_balancer_tcp_ports }}"
    when:
    - setup_firewalld | default(false)
    - load_balancer_tcp_ports is defined
    notify: Reload firewalld

  - name: Enable and start haproxy
    ansible.builtin.systemd:
      name: haproxy
      enabled: yes
      state: started
  when: load_balancer_enabled | default(false)
